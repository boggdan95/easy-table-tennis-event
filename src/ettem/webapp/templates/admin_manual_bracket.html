{% extends "base.html" %}

{% block title %}Bracket Manual - {{ category }} - ETTEM{% endblock %}

{% block page_title %}Bracket Manual: {{ category }}{% endblock %}

{% block topbar_actions %}
<a href="/admin/generate-bracket" class="btn btn-secondary btn-sm">
    <span>‚Üê</span>
    <span>Volver</span>
</a>
{% endblock %}

{% block content %}
<style>
.drag-container {
    display: grid;
    grid-template-columns: 1fr 2fr;
    gap: 1.5rem;
    margin-bottom: 1.5rem;
}

.players-pool {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.player-list {
    background: var(--card-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 1rem;
}

.player-list-title {
    font-weight: bold;
    margin-bottom: 0.75rem;
    padding-bottom: 0.5rem;
    border-bottom: 2px solid var(--primary-color);
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.player-item {
    background: white;
    border: 2px solid var(--border-color);
    border-radius: 4px;
    padding: 0.4rem 0.6rem;
    margin-bottom: 0.3rem;
    cursor: pointer;
    transition: all 0.15s;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.85rem;
}

.player-item:hover {
    background: var(--hover-bg, #f8f9fa);
    border-color: var(--primary-color);
}

.player-item.selected {
    background: var(--primary-bg, #e7f3ff);
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px var(--primary-color);
}

.player-item.dragging {
    opacity: 0.5;
    transform: scale(0.95);
}

.player-info {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 0.5rem;
}

.player-name {
    font-weight: 600;
    font-size: 0.85rem;
}

.player-meta {
    font-size: 0.75rem;
    color: var(--text-muted);
    display: flex;
    gap: 0.5rem;
}

.bracket-slots {
    background: var(--card-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 1rem;
}

.bracket-title {
    font-weight: bold;
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 2px solid var(--warning-color);
}

.bracket-half {
    margin-bottom: 1.5rem;
}

.half-label {
    font-weight: bold;
    font-size: 1.1rem;
    margin-bottom: 0.75rem;
    color: var(--primary-color);
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.slot-item {
    background: white;
    border: 2px dashed var(--border-color);
    border-radius: 4px;
    padding: 0.4rem 0.6rem;
    margin-bottom: 0.3rem;
    min-height: 36px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    transition: all 0.15s;
    cursor: pointer;
    font-size: 0.85rem;
}

.slot-item.slot-target {
    background: rgba(246, 173, 85, 0.15);
    border-color: var(--warning-color);
    border-style: solid;
}

.slot-item.drag-over {
    background: var(--primary-bg, #e7f3ff);
    border-color: var(--primary-color);
    border-style: solid;
}

.slot-item.occupied {
    background: var(--success-bg, #d4edda);
    border-style: solid;
    border-color: var(--success-color);
}

.slot-item.occupied:hover {
    background: rgba(72, 187, 120, 0.25);
}

.slot-item.dragging {
    opacity: 0.5;
    border: 2px dashed var(--primary-color);
}

.slot-number {
    font-weight: bold;
    color: var(--text-muted);
    font-size: 0.9rem;
    min-width: 28px;
}

.slot-content {
    flex: 1;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.slot-player {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
}

.slot-actions {
    display: flex;
    gap: 0.5rem;
}

.btn-remove {
    background: var(--danger-color);
    color: white;
    border: none;
    padding: 0.25rem 0.75rem;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.875rem;
}

.btn-remove:hover {
    background: var(--danger);
}

.warning-badge {
    background: var(--warning-color);
    color: white;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: bold;
}

.error-badge {
    background: var(--danger-color);
    color: white;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: bold;
}

.bye-slot {
    background: rgba(246, 173, 85, 0.2) !important;
    border: 2px solid var(--warning-color) !important;
    cursor: not-allowed !important;
    opacity: 0.8;
}

.bye-slot:hover {
    background: rgba(246, 173, 85, 0.2) !important;
    transform: none !important;
}

.group-badge {
    color: white;
    padding: 0.125rem 0.5rem;
    border-radius: 12px;
    font-size: 0.75rem;
    font-weight: bold;
    margin-right: 0.5rem;
    background: var(--primary-color);
}

.pot-legend {
    display: flex;
    flex-wrap: wrap;
    gap: 0.75rem;
    margin-bottom: 1rem;
    padding: 0.5rem 0.75rem;
    background: var(--card-bg);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    font-size: 0.8rem;
    align-items: center;
}

.pot-legend-title {
    font-weight: bold;
    font-size: 0.8rem;
}

.pot-legend-item {
    display: flex;
    align-items: center;
    gap: 0.3rem;
}

.pot-legend-swatch {
    width: 14px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid rgba(0,0,0,0.15);
}

@media (max-width: 768px) {
    .drag-container {
        grid-template-columns: 1fr;
    }
}
</style>

<div id="draft-notice" class="mb-3 info-box info-box-warning" style="padding: 0.6rem 1rem; display: none;">
    <div style="display: flex; align-items: center; justify-content: space-between;">
        <span style="font-size: 0.9rem;">
            <strong>üíæ Borrador recuperado</strong> - Se restaur√≥ el estado anterior del sorteo
        </span>
        <button type="button" onclick="discardDraft()" class="btn btn-warning btn-sm" style="padding: 0.2rem 0.6rem; font-size: 0.8rem;">
            Descartar borrador
        </button>
    </div>
</div>

<details class="mb-3 info-box info-box-info" style="padding: 0;">
    <summary style="padding: 0.6rem 1rem; cursor: pointer; font-weight: 600; color: var(--info); list-style: none; display: flex; align-items: center; gap: 0.5rem; font-size: 0.9rem;">
        <span class="details-arrow">‚ñ∂</span>
        <span>‚ÑπÔ∏è</span>
        <span>Instrucciones (click para ver)</span>
    </summary>
    <div style="padding: 0.5rem 1rem 0.75rem 1rem; font-size: 0.85rem;">
        <ul style="margin: 0; padding-left: 1.2rem;">
            <li><strong>Click para asignar:</strong> Click en jugador ‚Üí click en posici√≥n destino</li>
            <li><strong>Arrastrar:</strong> Tambi√©n puedes arrastrar jugadores (auto-scroll activado)</li>
            <li>Restricci√≥n: Jugadores del mismo grupo NO pueden ir en la misma mitad</li>
            <li>Los 2¬∫ de grupo solo pueden ir a la mitad opuesta del 1¬∫ de su grupo</li>
            <li>Los BYEs est√°n pre-colocados seg√∫n reglas ITTF</li>
            <li><strong>Auto-guardado:</strong> El progreso se guarda autom√°ticamente (sobrevive F5)</li>
        </ul>
    </div>
</details>
<style>
details .details-arrow { transition: transform 0.2s; font-size: 0.7rem; }
details[open] .details-arrow { transform: rotate(90deg); }
</style>

<div class="pot-legend">
    <span class="pot-legend-title">Pots ITTF:</span>
    <span class="pot-legend-item">
        <span class="pot-legend-swatch" style="background: #E74C3C;"></span> Seed 1-2 (G1-G2)
    </span>
    <span class="pot-legend-item">
        <span class="pot-legend-swatch" style="background: #9B59B6;"></span> Seed 3-4 (G3-G4)
    </span>
    <span class="pot-legend-item">
        <span class="pot-legend-swatch" style="background: #F1C40F;"></span> Seed 5-8 (G5-G8)
    </span>
    <span class="pot-legend-item">
        <span class="pot-legend-swatch" style="background: #27AE60;"></span> Seed 9-16 (G9-G16)
    </span>
    <span class="pot-legend-item">
        <span class="pot-legend-swatch" style="background: #e0e0e0;"></span> 2dos de Grupo
    </span>
</div>

<div class="drag-container">
    <!-- Players Pool (Left Side) -->
    <div class="players-pool">
        <!-- First Place Finishers -->
        <div class="player-list">
            <div class="player-list-title">
                <span>ü•á</span>
                <span>Primeros de Grupo ({{ firsts|length }})</span>
            </div>
            <div id="firsts-pool">
                {% for player in firsts %}
                <div class="player-item" draggable="true" data-player-id="{{ player.player_id }}" data-group-id="{{ player.group_id }}" data-group-name="{{ player.group_name }}" data-country="{{ player.pais_cd }}">
                    <div class="player-info">
                        <span class="group-badge">G{{ player.group_name }}</span>
                        <span class="player-name">{{ player.nombre }} {{ player.apellido }}</span>
                    </div>
                    <span class="badge badge-secondary" style="font-size: 0.7rem;">{{ player.pais_cd }}</span>
                </div>
                {% endfor %}
            </div>
        </div>

        <!-- Second Place Finishers -->
        <div class="player-list">
            <div class="player-list-title">
                <span>ü•à</span>
                <span>Segundos de Grupo ({{ seconds|length }})</span>
            </div>
            <div id="seconds-pool">
                {% for player in seconds %}
                <div class="player-item" draggable="true" data-player-id="{{ player.player_id }}" data-group-id="{{ player.group_id }}" data-group-name="{{ player.group_name }}" data-country="{{ player.pais_cd }}">
                    <div class="player-info">
                        <span class="group-badge">G{{ player.group_name }}</span>
                        <span class="player-name">{{ player.nombre }} {{ player.apellido }}</span>
                    </div>
                    <span class="badge badge-secondary" style="font-size: 0.7rem;">{{ player.pais_cd }}</span>
                </div>
                {% endfor %}
            </div>
        </div>

        <!-- BYEs Pool -->
        <div class="player-list">
            <div class="player-list-title">
                <span>‚è∏Ô∏è</span>
                <span>BYEs Disponibles</span>
            </div>
            <div id="byes-pool">
                <!-- BYEs will be added here dynamically when removed from slots -->
            </div>
        </div>
    </div>

    <!-- Bracket Slots (Right Side) -->
    <div class="bracket-slots">
        <div class="bracket-title">
            <span>üèÜ Bracket ({{ bracket_size }} posiciones)</span>
        </div>

        <form method="post" action="/admin/manual-bracket/{{ category }}/save" id="bracket-form">
            <!-- Top Half -->
            <div class="bracket-half">
                <div class="half-label">
                    <span>‚¨ÜÔ∏è</span>
                    <span>Mitad Superior (Posiciones 1-{{ bracket_size // 2 }})</span>
                </div>
                {% for slot in slots %}
                {% if slot.slot_number <= bracket_size // 2 %}
                <div class="slot-item {% if slot.is_bye %}bye-slot{% endif %}"
                     data-slot-number="{{ slot.slot_number }}"
                     data-half="top"
                     data-is-bye="{{ 'true' if slot.is_bye else 'false' }}">
                    <div class="slot-number">{{ slot.slot_number }}</div>
                    <div class="slot-content">
                        <div class="slot-player">
                            {% if slot.is_bye %}
                            <div style="font-weight: bold; color: var(--warning-color);">
                                üîí BYE
                            </div>
                            <div class="slot-actions">
                                <button type="button" class="btn-remove" onclick="removeBye({{ slot.slot_number }})">‚úï</button>
                            </div>
                            {% else %}
                            <span class="slot-placeholder">Vac√≠o - Arrastra un jugador aqu√≠</span>
                            {% endif %}
                        </div>
                    </div>
                    <input type="hidden" name="slot_{{ slot.slot_number }}" value="{% if slot.is_bye %}BYE{% endif %}">
                </div>
                {% endif %}
                {% endfor %}
            </div>

            <!-- Bottom Half -->
            <div class="bracket-half">
                <div class="half-label">
                    <span>‚¨áÔ∏è</span>
                    <span>Mitad Inferior (Posiciones {{ (bracket_size // 2) + 1 }}-{{ bracket_size }})</span>
                </div>
                {% for slot in slots %}
                {% if slot.slot_number > bracket_size // 2 %}
                <div class="slot-item {% if slot.is_bye %}bye-slot{% endif %}"
                     data-slot-number="{{ slot.slot_number }}"
                     data-half="bottom"
                     data-is-bye="{{ 'true' if slot.is_bye else 'false' }}">
                    <div class="slot-number">{{ slot.slot_number }}</div>
                    <div class="slot-content">
                        <div class="slot-player">
                            {% if slot.is_bye %}
                            <div style="font-weight: bold; color: var(--warning-color);">
                                üîí BYE
                            </div>
                            <div class="slot-actions">
                                <button type="button" class="btn-remove" onclick="removeBye({{ slot.slot_number }})">‚úï</button>
                            </div>
                            {% else %}
                            <span class="slot-placeholder">Vac√≠o - Arrastra un jugador aqu√≠</span>
                            {% endif %}
                        </div>
                    </div>
                    <input type="hidden" name="slot_{{ slot.slot_number }}" value="{% if slot.is_bye %}BYE{% endif %}">
                </div>
                {% endif %}
                {% endfor %}
            </div>

            <div class="d-flex gap-2" style="margin-top: 1.5rem;">
                <button type="submit" class="btn btn-success">
                    <span>üíæ</span>
                    <span>Guardar Bracket</span>
                </button>
                <a href="/admin/generate-bracket" class="btn btn-secondary">
                    <span>‚úï</span>
                    <span>Cancelar</span>
                </a>
                <button type="button" class="btn btn-warning" onclick="clearAllSlots()">
                    <span>üóëÔ∏è</span>
                    <span>Limpiar Todo</span>
                </button>
            </div>
        </form>
    </div>
</div>

<script>
// Track slot assignments for validation
const slotAssignments = {};
const bracketSize = {{ bracket_size }};
const halfPoint = Math.floor(bracketSize / 2);
const category = '{{ category }}';
const STORAGE_KEY = `ettem_bracket_draft_${category}`;

// ITTF Pot Colors ‚Äî maps bracket slot positions to seed pots
const POT_COLORS = {
    'seed1':   '#E74C3C',  // Red
    'seed2':   '#E74C3C',  // Red
    'seed3_4': '#9B59B6',  // Magenta
    'seed5_8': '#F1C40F',  // Gold
    'seed9_16':'#27AE60',  // Green
    'seed17_32':'#1ABC9C', // Cyan
};

// Get the pot for a bracket slot position (ITTF seeding algorithm)
function getSlotPot(slotNumber) {
    if (slotNumber === 1) return 'seed1';
    if (slotNumber === bracketSize) return 'seed2';

    const half = bracketSize / 2;
    if (slotNumber === half || slotNumber === half + 1) return 'seed3_4';

    if (bracketSize >= 16) {
        const quarter = bracketSize / 4;
        const q_positions = [quarter, quarter + 1, 3 * quarter, 3 * quarter + 1];
        if (q_positions.includes(slotNumber)) return 'seed5_8';
    }

    if (bracketSize >= 32) {
        const eighth = bracketSize / 8;
        for (let i = 1; i <= 7; i += 2) {
            if (slotNumber === i * eighth || slotNumber === i * eighth + 1) return 'seed9_16';
        }
    }

    if (bracketSize >= 64) {
        const sixteenth = bracketSize / 16;
        for (let i = 1; i <= 15; i += 2) {
            if (slotNumber === i * sixteenth || slotNumber === i * sixteenth + 1) return 'seed17_32';
        }
    }

    return null; // 2do de grupo ‚Äî no special color
}

// Get pot color for a group number
function getGroupPotColor(groupNum) {
    const g = parseInt(groupNum);
    if (g <= 2) return POT_COLORS.seed1;
    if (g <= 4) return POT_COLORS.seed3_4;
    if (g <= 8) return POT_COLORS.seed5_8;
    if (g <= 16) return POT_COLORS.seed9_16;
    if (g <= 32) return POT_COLORS.seed17_32;
    return null;
}

// Apply pot colors to all bracket slots and group badges
function applyPotColors() {
    // Color bracket slot positions (including BYE slots)
    document.querySelectorAll('.slot-item').forEach(slot => {
        const slotNum = parseInt(slot.dataset.slotNumber);
        const pot = getSlotPot(slotNum);
        if (pot && POT_COLORS[pot]) {
            slot.style.borderLeftWidth = '4px';
            slot.style.borderLeftStyle = 'solid';
            slot.style.borderLeftColor = POT_COLORS[pot];
        }
    });

    // Color group badges in player lists
    document.querySelectorAll('.group-badge').forEach(badge => {
        const text = badge.textContent.trim(); // e.g. "G1", "G3"
        const match = text.match(/G(\d+)/);
        if (match) {
            const groupNum = parseInt(match[1]);
            const color = getGroupPotColor(groupNum);
            if (color) {
                badge.style.background = color;
            }
        }
    });
}

// Drag and Drop Event Handlers
let draggedElement = null;

// Click-to-assign: track selected player
let selectedPlayer = null;

// Auto-scroll variables
let autoScrollInterval = null;
const SCROLL_SPEED = 15;
const SCROLL_ZONE = 80;

// Save state to localStorage
function saveState() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(slotAssignments));
}

// Restore state from localStorage
function restoreState() {
    const saved = localStorage.getItem(STORAGE_KEY);
    if (!saved) return;

    try {
        const savedAssignments = JSON.parse(saved);
        const allPlayers = [...{{ firsts | tojson }}, ...{{ seconds | tojson }}];

        Object.entries(savedAssignments).forEach(([slotNumber, data]) => {
            // Find player data to get full info
            const player = allPlayers.find(p => p.player_id == data.playerId);
            if (player) {
                assignPlayerToSlot(
                    parseInt(slotNumber),
                    data.playerId,
                    data.playerName,
                    data.groupId,
                    data.groupName,
                    data.country
                );
            }
        });

        if (Object.keys(savedAssignments).length > 0) {
            console.log(`Restored ${Object.keys(savedAssignments).length} assignments from draft`);
            // Show draft notice
            document.getElementById('draft-notice').style.display = 'block';
        }
    } catch (e) {
        console.error('Error restoring state:', e);
        localStorage.removeItem(STORAGE_KEY);
    }
}

// Clear saved draft
function clearDraft() {
    localStorage.removeItem(STORAGE_KEY);
    document.getElementById('draft-notice').style.display = 'none';
}

// Discard draft and reload page
function discardDraft() {
    if (confirm('¬øDescartar el borrador guardado? Se perder√°n las asignaciones actuales.')) {
        clearDraft();
        location.reload();
    }
}

document.addEventListener('DOMContentLoaded', function() {
    // Apply ITTF pot colors to slots and group badges
    applyPotColors();

    // Add event listeners to player items
    const playerItems = document.querySelectorAll('.player-item');
    playerItems.forEach(item => {
        item.addEventListener('dragstart', handleDragStart);
        item.addEventListener('dragend', handleDragEnd);
        item.addEventListener('click', handlePlayerClick);
    });

    // Add event listeners to slot items
    const slotItems = document.querySelectorAll('.slot-item');
    slotItems.forEach(slot => {
        slot.addEventListener('dragover', handleDragOver);
        slot.addEventListener('dragleave', handleDragLeave);
        slot.addEventListener('drop', handleDrop);
        slot.addEventListener('click', handleSlotClick);
    });

    // Auto-scroll during drag
    document.addEventListener('dragover', handleAutoScroll);
    document.addEventListener('dragend', stopAutoScroll);

    // Restore saved state (if not restoring from form validation error)
    {% if not saved_assignments %}
    restoreState();
    {% endif %}
});

// Click-to-assign handlers
function handlePlayerClick(e) {
    // Don't trigger if clicking remove button
    if (e.target.classList.contains('btn-remove')) return;

    const playerItem = e.currentTarget;

    // If this player is already selected, deselect
    if (selectedPlayer === playerItem) {
        deselectPlayer();
        return;
    }

    // Deselect previous and select this one
    deselectPlayer();
    selectedPlayer = playerItem;
    playerItem.classList.add('selected');

    // Highlight available slots
    highlightAvailableSlots();
}

function handleSlotClick(e) {
    // Don't trigger if clicking remove button or if slot is BYE
    if (e.target.classList.contains('btn-remove')) return;

    const slot = e.currentTarget;

    // If no player selected, ignore
    if (!selectedPlayer) return;

    // If slot is a BYE slot, can't place player
    if (slot.dataset.isBye === 'true') {
        alert('No puedes colocar un jugador en un slot de BYE');
        return;
    }

    // Get player data
    const playerId = selectedPlayer.dataset.playerId;
    const groupId = selectedPlayer.dataset.groupId;
    const groupName = selectedPlayer.dataset.groupName || groupId;
    const country = selectedPlayer.dataset.country;
    const slotNumber = parseInt(slot.dataset.slotNumber);
    const playerName = selectedPlayer.querySelector('.player-name').textContent.trim();

    // Check if player is already placed
    const existingSlots = Object.values(slotAssignments);
    if (existingSlots.some(s => s.playerId === playerId)) {
        alert('Este jugador ya est√° colocado en el bracket');
        deselectPlayer();
        return;
    }

    // For second place players, validate they go to opposite half
    const isSecondPlace = selectedPlayer.closest('#seconds-pool') !== null;
    if (isSecondPlace) {
        const slotHalf = slotNumber <= halfPoint ? 'top' : 'bottom';
        // Find if first place from same group is already placed
        for (const [slotNum, data] of Object.entries(slotAssignments)) {
            if (data.groupId === groupId) {
                const firstPlaceHalf = parseInt(slotNum) <= halfPoint ? 'top' : 'bottom';
                if (slotHalf === firstPlaceHalf) {
                    alert(`El 2¬∫ de G${groupName} debe ir en la mitad opuesta al 1¬∫ (que est√° en mitad ${firstPlaceHalf === 'top' ? 'superior' : 'inferior'})`);
                    deselectPlayer();
                    return;
                }
                break;
            }
        }
    }

    // Assign player to slot
    assignPlayerToSlot(slotNumber, playerId, playerName, groupId, groupName, country);

    // Deselect player
    deselectPlayer();
}

function deselectPlayer() {
    if (selectedPlayer) {
        selectedPlayer.classList.remove('selected');
        selectedPlayer = null;
    }
    // Remove slot highlights
    document.querySelectorAll('.slot-item').forEach(s => s.classList.remove('slot-target'));
}

function highlightAvailableSlots() {
    if (!selectedPlayer) return;

    const isSecondPlace = selectedPlayer.closest('#seconds-pool') !== null;
    const playerGroupId = selectedPlayer.dataset.groupId;
    let allowedHalf = null; // null = both halves allowed

    // For second place players, check where their group's first place is
    if (isSecondPlace) {
        // Find if first place from same group is already placed
        for (const [slotNum, data] of Object.entries(slotAssignments)) {
            if (data.groupId === playerGroupId) {
                // First place is in this slot, second must go to opposite half
                const firstPlaceHalf = parseInt(slotNum) <= halfPoint ? 'top' : 'bottom';
                allowedHalf = firstPlaceHalf === 'top' ? 'bottom' : 'top';
                break;
            }
        }
    }

    document.querySelectorAll('.slot-item').forEach(slot => {
        if (slot.dataset.isBye !== 'true' && !slot.classList.contains('occupied')) {
            const slotNumber = parseInt(slot.dataset.slotNumber);
            const slotHalf = slotNumber <= halfPoint ? 'top' : 'bottom';

            // If we have a restriction, only highlight allowed half
            if (allowedHalf === null || slotHalf === allowedHalf) {
                slot.classList.add('slot-target');
            }
        }
    });
}

// Auto-scroll during drag
function handleAutoScroll(e) {
    const y = e.clientY;
    const windowHeight = window.innerHeight;

    // Near top - scroll up
    if (y < SCROLL_ZONE) {
        startAutoScroll(-SCROLL_SPEED);
    }
    // Near bottom - scroll down
    else if (y > windowHeight - SCROLL_ZONE) {
        startAutoScroll(SCROLL_SPEED);
    }
    else {
        stopAutoScroll();
    }
}

function startAutoScroll(speed) {
    if (autoScrollInterval) return;
    autoScrollInterval = setInterval(() => {
        window.scrollBy(0, speed);
    }, 16);
}

function stopAutoScroll() {
    if (autoScrollInterval) {
        clearInterval(autoScrollInterval);
        autoScrollInterval = null;
    }
}

function handleDragStart(e) {
    draggedElement = e.target;
    e.target.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    // Deselect any selected player when starting drag
    deselectPlayer();
}

function handleDragEnd(e) {
    e.target.classList.remove('dragging');
    draggedElement = null;
    stopAutoScroll();
}

function handleDragOver(e) {
    if (e.preventDefault) {
        e.preventDefault();
    }
    e.dataTransfer.dropEffect = 'move';
    e.currentTarget.classList.add('drag-over');
    return false;
}

function handleDragLeave(e) {
    e.currentTarget.classList.remove('drag-over');
}

function handleDrop(e) {
    if (e.stopPropagation) {
        e.stopPropagation();
    }
    e.preventDefault();

    const targetSlot = e.currentTarget;
    targetSlot.classList.remove('drag-over');

    if (!draggedElement) {
        return false;
    }

    // Check if target slot is a BYE slot and we're dragging a player (not a BYE)
    if (targetSlot.dataset.isBye === 'true' &&
        (draggedElement.classList.contains('player-item') && !draggedElement.classList.contains('bye-item'))) {
        alert('No puedes colocar un jugador en un slot de BYE');
        return false;
    }

    // Check if target slot has a player and we're dragging a BYE
    const slotNumber = parseInt(targetSlot.dataset.slotNumber);
    if (draggedElement.classList.contains('bye-item') && slotAssignments[slotNumber]) {
        alert('No puedes colocar un BYE en un slot ocupado por un jugador');
        return false;
    }

    // Case 1: Dragging from player list
    if (draggedElement.classList.contains('player-item') && !draggedElement.classList.contains('bye-item')) {
        const playerId = draggedElement.dataset.playerId;
        const groupId = draggedElement.dataset.groupId;
        const groupName = draggedElement.dataset.groupName || groupId;
        const country = draggedElement.dataset.country;
        const slotNumber = parseInt(targetSlot.dataset.slotNumber);
        const playerName = draggedElement.querySelector('.player-name').textContent.trim();

        // Check if player is already in bracket
        const existingSlots = Object.values(slotAssignments);
        const isAlreadyPlaced = existingSlots.some(s => s.playerId === playerId);

        if (isAlreadyPlaced) {
            alert('Este jugador ya est√° colocado en el bracket');
            return false;
        }

        // For second place players, validate they go to opposite half
        const isSecondPlace = draggedElement.closest('#seconds-pool') !== null;
        if (isSecondPlace) {
            const slotHalf = slotNumber <= halfPoint ? 'top' : 'bottom';
            for (const [slotNum, data] of Object.entries(slotAssignments)) {
                if (data.groupId === groupId) {
                    const firstPlaceHalf = parseInt(slotNum) <= halfPoint ? 'top' : 'bottom';
                    if (slotHalf === firstPlaceHalf) {
                        alert(`El 2¬∫ de G${groupName} debe ir en la mitad opuesta al 1¬∫ (que est√° en mitad ${firstPlaceHalf === 'top' ? 'superior' : 'inferior'})`);
                        return false;
                    }
                    break;
                }
            }
        }

        // Assign player to slot
        assignPlayerToSlot(slotNumber, playerId, playerName, groupId, groupName, country);
    }
    // Case 2: Dragging from another slot (moving within bracket)
    else if (draggedElement.classList.contains('slot-item')) {
        const sourceSlotNumber = parseInt(draggedElement.dataset.slotNumber);
        const targetSlotNumber = parseInt(targetSlot.dataset.slotNumber);

        // Don't do anything if dropping on same slot
        if (sourceSlotNumber === targetSlotNumber) {
            return false;
        }

        // Check if source slot is a BYE
        if (draggedElement.dataset.isBye === 'true') {
            alert('No puedes mover un BYE');
            return false;
        }

        // Get source player data
        const sourceData = slotAssignments[sourceSlotNumber];
        if (!sourceData) {
            return false; // No player in source slot
        }

        // If target slot has a player, swap them
        const targetData = slotAssignments[targetSlotNumber];

        if (targetData) {
            // Swap: move target player to source slot
            assignPlayerToSlot(
                sourceSlotNumber,
                targetData.playerId,
                targetData.playerName,
                targetData.groupId,
                targetData.groupName,
                targetData.country
            );
        } else {
            // Just move: clear source slot
            removePlayerFromSlot(sourceSlotNumber);
        }

        // Move source player to target slot
        assignPlayerToSlot(
            targetSlotNumber,
            sourceData.playerId,
            sourceData.playerName,
            sourceData.groupId,
            sourceData.groupName,
            sourceData.country
        );
    }
    // Case 3: Dragging a BYE from the pool
    else if (draggedElement.classList.contains('bye-item')) {
        const slotNumber = parseInt(targetSlot.dataset.slotNumber);

        // Assign BYE to slot
        assignByeToSlot(slotNumber);

        // Remove BYE from pool
        draggedElement.remove();
    }

    return false;
}

function assignPlayerToSlot(slotNumber, playerId, playerName, groupId, groupName, country) {
    const slot = document.querySelector(`.slot-item[data-slot-number="${slotNumber}"]`);
    const input = slot.querySelector('input[type="hidden"]');
    const contentDiv = slot.querySelector('.slot-player');

    // Update slot
    slot.classList.add('occupied');
    input.value = playerId;

    const badgeColor = getGroupPotColor(groupName) || 'var(--primary-color)';
    contentDiv.innerHTML = `
        <div style="display: flex; align-items: center; gap: 0.5rem; flex: 1;">
            <span class="group-badge" style="background: ${badgeColor};">G${groupName}</span>
            <span style="font-weight: 600; font-size: 0.85rem;">${playerName}</span>
            <span class="badge badge-secondary" style="font-size: 0.7rem;">${country}</span>
        </div>
        <button type="button" class="btn-remove" onclick="removePlayerFromSlot(${slotNumber})" style="padding: 0.15rem 0.4rem; font-size: 0.75rem;">‚úï</button>
    `;

    // Make the slot draggable
    slot.draggable = true;
    slot.style.cursor = 'move';

    // Add drag event listeners if not already added
    if (!slot.hasAttribute('data-drag-enabled')) {
        slot.addEventListener('dragstart', handleDragStart);
        slot.addEventListener('dragend', handleDragEnd);
        slot.setAttribute('data-drag-enabled', 'true');
    }

    // Hide player from the pool list
    const playerItem = document.querySelector(`.player-item[data-player-id="${playerId}"]`);
    if (playerItem) {
        playerItem.style.display = 'none';
    }

    // Track assignment (include playerName and groupName for swapping)
    slotAssignments[slotNumber] = { playerId, playerName, groupId, groupName, country };

    // Save state to localStorage
    saveState();

    // Validate constraints
    validateConstraints();
}

function removePlayerFromSlot(slotNumber) {
    const slot = document.querySelector(`.slot-item[data-slot-number="${slotNumber}"]`);
    const input = slot.querySelector('input[type="hidden"]');
    const contentDiv = slot.querySelector('.slot-player');

    // Get player ID before removing from tracking
    const playerData = slotAssignments[slotNumber];
    const playerId = playerData ? playerData.playerId : null;

    // Clear slot
    slot.classList.remove('occupied');
    input.value = '';
    contentDiv.innerHTML = '<span class="slot-placeholder">Vac√≠o - Arrastra un jugador aqu√≠</span>';

    // Make the slot non-draggable again
    slot.draggable = false;
    slot.style.cursor = '';
    slot.removeAttribute('data-drag-enabled');

    // Remove from tracking
    delete slotAssignments[slotNumber];

    // Show player back in the pool list
    if (playerId) {
        const playerItem = document.querySelector(`.player-item[data-player-id="${playerId}"]`);
        if (playerItem) {
            playerItem.style.display = '';
        }
    }

    // Save state to localStorage
    saveState();

    // Revalidate
    validateConstraints();
}

function removeBye(slotNumber) {
    const slot = document.querySelector(`.slot-item[data-slot-number="${slotNumber}"]`);
    const input = slot.querySelector('input[type="hidden"]');
    const contentDiv = slot.querySelector('.slot-player');

    // Remove BYE marking
    slot.classList.remove('bye-slot');
    slot.dataset.isBye = 'false';

    // Clear input (was set to 'BYE')
    input.value = '';

    // Update UI to show empty slot
    contentDiv.innerHTML = '<span class="slot-placeholder">Vac√≠o - Arrastra un jugador aqu√≠</span>';

    // Add BYE back to the pool
    addByeToPool();
}

function assignByeToSlot(slotNumber) {
    const slot = document.querySelector(`.slot-item[data-slot-number="${slotNumber}"]`);
    const input = slot.querySelector('input[type="hidden"]');
    const contentDiv = slot.querySelector('.slot-player');

    // Mark slot as BYE
    slot.classList.add('bye-slot');
    slot.dataset.isBye = 'true';

    // Set input value
    input.value = 'BYE';

    // Update UI
    contentDiv.innerHTML = `
        <div style="font-weight: bold; color: var(--warning-color);">
            üîí BYE
        </div>
        <div class="slot-actions">
            <button type="button" class="btn-remove" onclick="removeBye(${slotNumber})">‚úï</button>
        </div>
    `;
}

function addByeToPool() {
    const byesPool = document.getElementById('byes-pool');

    // Create BYE item
    const byeItem = document.createElement('div');
    byeItem.className = 'player-item bye-item';
    byeItem.draggable = true;
    byeItem.innerHTML = `
        <div class="player-info">
            <div class="player-name" style="color: var(--warning-color); font-weight: bold;">
                üîí BYE
            </div>
            <div class="player-meta">
                <span class="badge badge-warning">Disponible</span>
            </div>
        </div>
        <span style="font-size: 1.5rem; color: var(--text-muted);">‚ãÆ‚ãÆ</span>
    `;

    // Add drag event listeners
    byeItem.addEventListener('dragstart', handleDragStart);
    byeItem.addEventListener('dragend', handleDragEnd);

    // Add to pool
    byesPool.appendChild(byeItem);
}

function clearAllSlots() {
    if (confirm('¬øSeguro que quieres limpiar todas las posiciones? (Tambi√©n se borrar√° el borrador guardado)')) {
        Object.keys(slotAssignments).forEach(slotNumber => {
            removePlayerFromSlot(parseInt(slotNumber));
        });
        clearDraft();
    }
}

function validateConstraints() {
    // Clear all warnings
    document.querySelectorAll('.warning-badge, .error-badge').forEach(badge => badge.remove());

    // Check same-group constraint
    const topHalfGroups = new Set();
    const bottomHalfGroups = new Set();
    let violations = [];

    Object.entries(slotAssignments).forEach(([slotNumber, data]) => {
        const slot = parseInt(slotNumber);
        const half = slot <= halfPoint ? 'top' : 'bottom';

        if (half === 'top') {
            if (topHalfGroups.has(data.groupId)) {
                violations.push(`Grupo ${data.groupId} repetido en mitad superior`);
            }
            topHalfGroups.add(data.groupId);
        } else {
            if (bottomHalfGroups.has(data.groupId)) {
                violations.push(`Grupo ${data.groupId} repetido en mitad inferior`);
            }
            bottomHalfGroups.add(data.groupId);
        }
    });

    // Show violations
    if (violations.length > 0) {
        alert('ADVERTENCIA DE VALIDACI√ìN:\n\n' + violations.join('\n'));
    }

    // Check same-country warnings in first round matchups
    for (let i = 1; i < bracketSize; i += 2) {
        const slot1 = slotAssignments[i];
        const slot2 = slotAssignments[i + 1];

        if (slot1 && slot2 && slot1.country === slot2.country) {
            const slotElement1 = document.querySelector(`.slot-item[data-slot-number="${i}"] .slot-content`);
            const slotElement2 = document.querySelector(`.slot-item[data-slot-number="${i + 1}"] .slot-content`);

            const warning = '<span class="warning-badge">‚ö†Ô∏è Mismo pa√≠s</span>';
            slotElement1.insertAdjacentHTML('beforeend', warning);
            slotElement2.insertAdjacentHTML('beforeend', warning);
        }
    }
}

// Form validation before submit
document.getElementById('bracket-form').addEventListener('submit', function(e) {
    const assignedCount = Object.keys(slotAssignments).length;
    if (assignedCount === 0) {
        e.preventDefault();
        alert('Debes asignar al menos un jugador al bracket');
        return false;
    }

    // Double-check same-group constraint
    const topHalfGroups = [];
    const bottomHalfGroups = [];

    Object.entries(slotAssignments).forEach(([slotNumber, data]) => {
        const slot = parseInt(slotNumber);
        if (slot <= halfPoint) {
            topHalfGroups.push(data.groupId);
        } else {
            bottomHalfGroups.push(data.groupId);
        }
    });

    const topDupes = topHalfGroups.length !== new Set(topHalfGroups).size;
    const bottomDupes = bottomHalfGroups.length !== new Set(bottomHalfGroups).size;

    if (topDupes || bottomDupes) {
        e.preventDefault();
        alert('ERROR: Hay jugadores del mismo grupo en la misma mitad del bracket. Por favor corrige las asignaciones.');
        return false;
    }

    // Don't clear draft here - let the server confirm success first
    // The draft will be cleared when redirected to success page
    return true;
});

// Restore form state if there was a validation error
{% if saved_assignments %}
(function() {
    const savedData = {{ saved_assignments | tojson }};
    const allPlayers = [...{{ firsts | tojson }}, ...{{ seconds | tojson }}];

    // Convert saved form data (slot_1: player_id, slot_2: BYE, etc.) to assignments
    Object.entries(savedData).forEach(([key, value]) => {
        if (key.startsWith('slot_')) {
            const slotNumber = parseInt(key.replace('slot_', ''));

            // Skip BYE slots
            if (value === 'BYE' || value === '') {
                return;
            }

            // Find player data
            const playerId = parseInt(value);
            const player = allPlayers.find(p => p.player_id === playerId);

            if (player) {
                const playerName = `${player.nombre} ${player.apellido}`;
                assignPlayerToSlot(
                    slotNumber,
                    player.player_id,
                    playerName,
                    player.group_id,
                    player.group_name || player.group_id,
                    player.pais_cd
                );
            }
        }
    });
})();
{% endif %}
</script>

{% endblock %}
